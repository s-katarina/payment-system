# Navigate to nginx directory
# cd C:\path\to\nginx

# Test configuration
# nginx -t -c C:\nginx-psp-gateway.conf

# Start nginx with your config
# nginx -c C:nginx-psp-gateway.conf

# ============================================
# UPSTREAM BLOCK - Backend Server Definition
# ============================================
upstream psp_backend {
    # Defines the backend server(s) that NGINX will forward requests to
    server localhost:8081 max_fails=3 fail_timeout=30s;
    
    # max_fails=3: After 3 failed requests, mark server as unavailable
    # fail_timeout=20s: Keep server marked as unavailable for 30 seconds, then retry
    
    # Load balancing method
    least_conn;  # Routes to server with fewest active connections
    # Alternatives:
    # - round_robin (default): Distribute requests evenly
    # - ip_hash: Route same client IP to same server (session persistence)
}

# ============================================
# SERVER BLOCK - API Gateway Configuration
# ============================================
server {
    listen 8090;
    server_name localhost;  # Server name for this virtual host
    error_log logs/psp_gateway_error.log;     # Log errors only

    proxy_connect_timeout 5s;      # Max time to establish TCP connection to backend
    proxy_send_timeout 10s;        # Max time to send request to backend
    proxy_read_timeout 10s;        # Max time to wait for response from backend
    proxy_next_upstream_timeout 5s; # Max time before trying next upstream server

    # Forward important headers to backend so it knows the original request info
    proxy_set_header Host $host;                    # Original host header
    proxy_set_header X-Real-IP $remote_addr;       # Client's real IP address
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # Proxy chain
    proxy_set_header X-Forwarded-Proto $scheme;    # Original protocol (http/https)

    # ============================================
    # ROUTING RULES
    # ============================================
    # This location block matches any request that starts with /api/v1/payment/
    # Examples: /api/v1/payment/create, /api/v1/payment/status/123, etc.
    location /api/v1/payment/ {
        
        # STEP 1: Forward the request to PSP backend
        # When a request comes to http://localhost:8090/api/v1/payment/create,
        # NGINX will forward it to http://localhost:8081/api/v1/payment/create
        # (The /api/v1/payment/ part is preserved because proxy_pass doesn't end with /)
        proxy_pass http://psp_backend;
        
        # STEP 2: Define what errors should trigger a retry to another backend server
        # for multiple PSP instances (load balancing)
        # NGINX will try the next server in the upstream block if these errors occur:
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        # 
        # - error: Cannot establish TCP connection (e.g., PSP service is completely down)
        # - timeout: Request took too long (exceeded proxy_read_timeout of 10s)
        # - invalid_header: Backend returned malformed HTTP headers
        # - http_500: Backend returned HTTP 500 Internal Server Error
        # - http_502: Backend returned HTTP 502 Bad Gateway (rare, usually NGINX generates this)
        # - http_503: Backend returned HTTP 503 Service Unavailable
        # - http_504: Backend returned HTTP 504 Gateway Timeout
        
        # STEP 3: Limit how many times to retry
        # For demo only 1 PSP backend runs, set to 1 (no retries to other servers)
        proxy_next_upstream_tries 1;
        
        # STEP 4: Enable error interception
        #
        # When proxy_intercept_errors is ON:
        # 1. NGINX receives response from backend (e.g., HTTP 503)
        # 2. NGINX checks if status code is >= 400 (error status)
        # 3. Instead of forwarding it immediately, NGINX "holds" the response
        # 4. NGINX then checks for error_page directives that match this status code
        # 5. If found, NGINX generates a NEW response using the error_page location
        # 6. This new response is sent to client instead of the original error
        #
        # - error_page directive tells NGINX: "when you see error X, generate response Y instead"
        #
        # WITHOUT interception (proxy_intercept_errors off):
        # Backend 503 → NGINX → Client (503 passed through directly)
        #
        # WITH interception (proxy_intercept_errors on):
        # Backend 503 → NGINX intercepts → Checks error_page → Generates new response → Client (503 JSON)
        proxy_intercept_errors on;
        
        # STEP 5: Transform PSP backend errors into JSON responses
        # This ONLY applies to errors from the PSP backend (this location block)
        # Other errors (like 404 for wrong paths) will use default NGINX error pages
        #
        # If PSP backend returns 502, 503, or 504, NGINX will:
        # 1. Intercept that error response
        # 2. Instead of sending it to the client, serve the /psp_error.json location
        # 3. Return HTTP 503 with the JSON body defined in that location block
        #
        # Also handle connection errors (when PSP is completely down):
        # - If NGINX can't connect to PSP, it generates a 502 Bad Gateway
        # - This error_page will catch it and return JSON instead
        #
        # Example flow:
        # Client → NGINX → PSP Backend (down/error) → NGINX intercepts → 
        # NGINX serves /psp_error.json → Client receives 503 with JSON message
        error_page 502 503 504 =503 /psp_error.json;
    }

    # ============================================
    # HEALTH CHECK ENDPOINT
    # ============================================
    location /health {
        access_log off;  # Don't log health checks
        return 200 "healthy\n";  # Return 200 OK with "healthy" message
        add_header Content-Type text/plain;
    }

    # ============================================
    # PSP BACKEND ERROR RESPONSE (JSON ONLY)
    # ============================================
    # 
    # SUMMARY:
    # This is a "template" for error responses when the PSP backend fails.
    # When PSP is down/unavailable, instead of showing a generic HTML error page,
    # NGINX will return a clean JSON error message to API clients.
    #
    # HOW IT WORKS:
    # 1. Client requests: http://localhost:8090/api/v1/payment/create
    # 2. NGINX tries to forward to PSP backend (localhost:8081)
    # 3. PSP is down → NGINX detects error (502/503/504)
    # 4. NGINX sees error_page directive in the location block above
    # 5. NGINX internally calls this /psp_error.json location
    # 6. This location returns: HTTP 503 + JSON body
    # 7. Client receives: {"error":"Service Unavailable","message":"PSP service..."}
    #
    # KEY POINTS:
    # - This location is INTERNAL ONLY (users can't access it directly)
    # - Only triggered when PSP backend has errors (502, 503, 504)
    # - Returns JSON (not HTML) so API clients can parse it easily
    # - The error_page directive in the PSP location block (line 94) references this
    #
    # ============================================
    location = /psp_error.json {
        
        # INTERNAL: This location can only be accessed by NGINX internally
        # External clients CANNOT directly access http://localhost:8090/psp_error.json
        # This prevents users from bypassing your API and seeing error pages directly
        # Only NGINX's error_page directive (from PSP location block) can trigger this
        internal;
        
        # Set the Content-Type header to application/json
        # This tells the client (browser/API client) that the response is JSON
        # Without this, the client might try to parse it as HTML or plain text
        default_type application/json;
        
        # Return HTTP 503 (Service Unavailable) with a JSON body
        # This is ONLY used for PSP backend errors (502, 503, 504 from PSP service)
        # When NGINX intercepts a PSP error, it will:
        # 1. Serve this location block
        # 2. Return HTTP status 503
        # 3. Send this JSON string as the response body
        #
        # Example response to client when PSP is unavailable:
        # HTTP/1.1 503 Service Unavailable
        # Content-Type: application/json
        # 
        # {"error":"Service Unavailable","message":"PSP service is temporarily unavailable. Please try again later."}
        return 503 '{"error":"Service Unavailable","message":"PSP service is temporarily unavailable. Please try again later."}';
    }
}